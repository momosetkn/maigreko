package momosetkn.maigreko.introspector

import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.collections.shouldContainAll
import io.kotest.matchers.shouldBe
import io.kotest.matchers.string.shouldContain
import momosetkn.JdbcDatabaseContainerDataSource
import momosetkn.PostgresqlDatabase
import momosetkn.maigreko.change.AddForeignKey
import momosetkn.maigreko.change.AddNotNullConstraint
import momosetkn.maigreko.change.AddUniqueConstraint
import momosetkn.maigreko.change.Change
import momosetkn.maigreko.change.Column
import momosetkn.maigreko.change.CreateSequence
import momosetkn.maigreko.change.CreateTable
import momosetkn.maigreko.sql.PostgresqlMigrateEngine
import java.sql.Connection
import javax.sql.DataSource

class PostgresqlChangeGeneratorIntegrationSpec : FunSpec({
    val logger = org.slf4j.LoggerFactory.getLogger(PostgresqlChangeGeneratorIntegrationSpec::class.java)
    val postgresqlMigrateEngine = PostgresqlMigrateEngine()

    lateinit var connection: Connection
    lateinit var dataSource: DataSource
    lateinit var postgresqlInfoService: PostgresqlInfoService
    lateinit var changeGenerator: PostgresqlChangeGenerator

    beforeSpec {
        PostgresqlDatabase.start()
        val container = PostgresqlDatabase.startedContainer
        dataSource = JdbcDatabaseContainerDataSource(container)
        logger.info("Connected to PostgreSQL: ${container.jdbcUrl}")
        connection = dataSource.connection
        postgresqlInfoService = PostgresqlInfoService(dataSource)
        changeGenerator = PostgresqlChangeGenerator()
    }

    afterSpec {
        connection.close()
        PostgresqlDatabase.stop()
    }

    beforeTest {
        PostgresqlDatabase.clear()
    }

    afterTest {
        logger.info("Generated DDL:")
        logger.info(PostgresqlDatabase.generateDdl())
    }

    fun subject(
        connection: Connection
    ): Triple<List<Change>, String, String> {
        val (tableInfoss, sequenceDetails) = postgresqlInfoService.fetchAll()

        // Generate changes
        val changes = changeGenerator.generateChanges(
            tableInfoss = tableInfoss,
            sequenceDetails = sequenceDetails
        )

        // Store the original DDL for comparison
        val originalDdl = PostgresqlDatabase.generateDdl()

        // Clear the database
        PostgresqlDatabase.clear()

        // Apply the changes using PostgreMigrateEngine
        changes.forEach { change ->
            val ddl = postgresqlMigrateEngine.forwardDdl(change)
            connection.createStatement().use { statement ->
                statement.execute(ddl)
            }
        }

        // Get the resulting DDL
        val resultingDdl = PostgresqlDatabase.generateDdl()
        return Triple(changes, originalDdl, resultingDdl)
    }

    context("Single table schema") {
        test("should generate changes for a simple table") {
            // Create a test table
            connection.createStatement().use { statement ->
                statement.execute(
                    """
                    CREATE TABLE users (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        username VARCHAR(255) NOT NULL UNIQUE,
                        email VARCHAR(255) NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """
                )
            }

            val (changes, originalDdl, resultingDdl) = subject(connection)

            // Verify changes
            changes.filterIsInstance<CreateTable>().size shouldBe 1

            val createTable = changes.filterIsInstance<CreateTable>().first()
            createTable.tableName shouldBe "users"
            createTable.columns.size shouldBe 4

            // Verify column names
            val columnNames = createTable.columns.map { it.name }
            columnNames shouldContainAll listOf("id", "username", "email", "created_at")

            // Verify constraints
            changes.filterIsInstance<AddNotNullConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<AddUniqueConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<CreateSequence>().size shouldBe 0 // include CreateTable change

            resultingDdl shouldBe originalDdl
        }
    }

    context("Tables with foreign key relationships") {
        test("should generate changes with proper dependency ordering") {
            // Create test tables with foreign key relationship
            connection.createStatement().use { statement ->
                statement.execute(
                    """
                    CREATE TABLE departments (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL UNIQUE
                    )
                """
                )

                statement.execute(
                    """
                    CREATE TABLE employees (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        department_id INTEGER NOT NULL,
                        CONSTRAINT fk_department FOREIGN KEY (department_id) 
                            REFERENCES departments(id) ON DELETE CASCADE
                    )
                """
                )
            }

            val (changes, originalDdl, resultingDdl) = subject(connection)

            // Verify the order - departments should come before employees
            val deptTableIndex = changes.indexOfFirst {
                it is CreateTable && it.tableName == "departments"
            }
            val empTableIndex = changes.indexOfFirst {
                it is CreateTable && it.tableName == "employees"
            }

            // Departments should come before employees
            (deptTableIndex < empTableIndex) shouldBe true

            // Check if foreign keys are present in the sorted changes
            val foreignKeys = changes.filterIsInstance<AddForeignKey>()

            // If foreign keys are present, verify their details
            if (foreignKeys.isNotEmpty()) {
                val fkIndex = changes.indexOfFirst {
                    it is AddForeignKey && (it as AddForeignKey).tableName == "employees"
                }

                // Foreign key should come after both tables
                if (fkIndex >= 0) {
                    (fkIndex > deptTableIndex && fkIndex > empTableIndex) shouldBe true

                    val fk = foreignKeys.first { it.tableName == "employees" }
                    fk.referencedTableName shouldBe "departments"
                    fk.columnNames shouldBe listOf("department_id")
                    fk.referencedColumnNames shouldBe listOf("id")
                }
            }

            changes.filterIsInstance<AddNotNullConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<AddUniqueConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<CreateSequence>().size shouldBe 0 // include CreateTable change

            resultingDdl shouldBe originalDdl
        }
    }

    context("Validate changes by applying them to database") {
        test("should generate and apply changes for a simple table") {
            // Create a test table
            connection.createStatement().use { statement ->
                statement.execute(
                    """
                    CREATE TABLE users (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        username VARCHAR(255) NOT NULL UNIQUE,
                        email VARCHAR(255) NOT NULL,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                """
                )
            }

            val (changes, originalDdl, resultingDdl) = subject(connection)

            // Verify the DDL contains expected elements
            resultingDdl shouldContain "CREATE TABLE public.users"
            resultingDdl shouldContain "id"
            resultingDdl shouldContain "username"
            resultingDdl shouldContain "email"
            resultingDdl shouldContain "created_at"

            changes.filterIsInstance<AddNotNullConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<AddUniqueConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<CreateSequence>().size shouldBe 0 // include CreateTable change

            resultingDdl shouldBe originalDdl
        }

        test("should generate and apply changes for tables with relationships") {
            // Create test tables with foreign key relationship
            connection.createStatement().use { statement ->
                statement.execute(
                    """
                    CREATE TABLE departments (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL UNIQUE
                    )
                """
                )

                statement.execute(
                    """
                    CREATE TABLE employees (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        department_id INTEGER NOT NULL,
                        CONSTRAINT fk_department FOREIGN KEY (department_id) 
                            REFERENCES departments(id) ON DELETE CASCADE
                    )
                """
                )
            }

            val (changes, originalDdl, resultingDdl) = subject(connection)

            // Verify the DDL contains expected elements
            resultingDdl shouldContain "CREATE TABLE public.departments"
            resultingDdl shouldContain "CREATE TABLE public.employees"
            resultingDdl shouldContain "department_id"

            changes.filterIsInstance<AddNotNullConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<AddUniqueConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<CreateSequence>().size shouldBe 0 // include CreateTable change

            resultingDdl shouldBe originalDdl
        }
    }

    context("Complex schema with multiple relationships") {
        test("should generate, apply, and validate changes for a complex schema") {
            // Create a more complex schema with multiple tables and relationships
            connection.createStatement().use { statement ->
                // Categories table
                statement.execute(
                    """
                    CREATE TABLE categories (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL UNIQUE
                    )
                """
                )

                // Products table with category foreign key
                statement.execute(
                    """
                    CREATE TABLE products (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        price NUMERIC(10,2) NOT NULL,
                        category_id INTEGER NOT NULL,
                        CONSTRAINT fk_category FOREIGN KEY (category_id) 
                            REFERENCES categories(id) ON DELETE RESTRICT
                    )
                """
                )

                // Customers table
                statement.execute(
                    """
                    CREATE TABLE customers (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        email VARCHAR(255) NOT NULL UNIQUE
                    )
                """
                )

                // Orders table with customer foreign key
                statement.execute(
                    """
                    CREATE TABLE orders (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                        customer_id INTEGER NOT NULL,
                        CONSTRAINT fk_customer FOREIGN KEY (customer_id) 
                            REFERENCES customers(id) ON DELETE CASCADE
                    )
                """
                )

                // Order items table with order and product foreign keys
                statement.execute(
                    """
                    CREATE TABLE order_items (
                        id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        order_id INTEGER NOT NULL,
                        product_id INTEGER NOT NULL,
                        quantity INTEGER NOT NULL,
                        CONSTRAINT fk_order FOREIGN KEY (order_id) 
                            REFERENCES orders(id) ON DELETE CASCADE,
                        CONSTRAINT fk_product FOREIGN KEY (product_id) 
                            REFERENCES products(id) ON DELETE RESTRICT
                    )
                """
                )
            }
            val (changes, originalDdl, resultingDdl) = subject(connection)

            // Verify the DDL contains expected elements for all tables
            resultingDdl shouldContain "CREATE TABLE public.categories"
            resultingDdl shouldContain "CREATE TABLE public.products"
            resultingDdl shouldContain "CREATE TABLE public.customers"
            resultingDdl shouldContain "CREATE TABLE public.orders"
            resultingDdl shouldContain "CREATE TABLE public.order_items"

            // Verify column names
            resultingDdl shouldContain "category_id"
            resultingDdl shouldContain "customer_id"
            resultingDdl shouldContain "order_id"
            resultingDdl shouldContain "product_id"

            changes.filterIsInstance<AddNotNullConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<AddUniqueConstraint>().size shouldBe 0 // include CreateTable change
            changes.filterIsInstance<CreateSequence>().size shouldBe 0 // include CreateTable change

            resultingDdl shouldBe originalDdl
        }
    }

    context("SERIAL and IDENTITY column types") {
        test("should handle all required PostgreSQL column types and constraints") {
            // Create tables with different column types and constraints
            connection.createStatement().use { statement ->
                // 1. Create a table with SERIAL types
                statement.execute(
                    """
                    CREATE TABLE serial_types (
                        id_smallserial SMALLSERIAL PRIMARY KEY,
                        id_serial SERIAL NOT NULL,
                        id_bigserial BIGSERIAL NOT NULL
                    )
                    """
                )

                // 2. Create a table with IDENTITY columns with different configurations
                statement.execute(
                    """
                    CREATE TABLE identity_types (
                        id_default INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        id_always INTEGER GENERATED ALWAYS AS IDENTITY NOT NULL,
                        id_custom INTEGER GENERATED BY DEFAULT AS IDENTITY (START WITH 100 INCREMENT BY 10) NOT NULL,
                        id_cycle INTEGER GENERATED BY DEFAULT AS IDENTITY (CYCLE) NOT NULL,
                        id_no_cycle INTEGER GENERATED BY DEFAULT AS IDENTITY (NO CYCLE) NOT NULL
                    )
                    """
                )

                // 3. Create tables with foreign keys
                statement.execute(
                    """
                    CREATE TABLE departments (
                        id SERIAL PRIMARY KEY,
                        name VARCHAR(255) NOT NULL UNIQUE
                    )
                    """
                )

                statement.execute(
                    """
                    CREATE TABLE employees (
                        id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        department_id INTEGER NOT NULL,
                        CONSTRAINT fk_department FOREIGN KEY (department_id) 
                            REFERENCES departments(id) ON DELETE CASCADE
                    )
                    """
                )

                statement.execute(
                    """
                    CREATE TABLE projects (
                        id BIGSERIAL PRIMARY KEY,
                        name VARCHAR(255) NOT NULL,
                        department_id INTEGER NOT NULL,
                        manager_id INTEGER NOT NULL,
                        CONSTRAINT fk_dept FOREIGN KEY (department_id) 
                            REFERENCES departments(id) ON DELETE RESTRICT,
                        CONSTRAINT fk_manager FOREIGN KEY (manager_id) 
                            REFERENCES employees(id) ON DELETE RESTRICT
                    )
                    """
                )
            }

            val (changes, originalDdl, resultDdl) = subject(connection)

            // Verify SERIAL types
            val serialTable = changes.filterIsInstance<CreateTable>().first { it.tableName == "serial_types" }

            // Check column types for SERIAL
            val smallserialColumn = serialTable.columns.first { it.name == "id_smallserial" }
            val serialColumn = serialTable.columns.first { it.name == "id_serial" }
            val bigserialColumn = serialTable.columns.first { it.name == "id_bigserial" }

            smallserialColumn.type shouldContain "smallint"
            serialColumn.type shouldContain "integer"
            bigserialColumn.type shouldContain "bigint"

            // Verify IDENTITY columns
            val identityTable = changes.filterIsInstance<CreateTable>().first { it.tableName == "identity_types" }

            // Check identity generation types
            val defaultColumn = identityTable.columns.first { it.name == "id_default" }
            val alwaysColumn = identityTable.columns.first { it.name == "id_always" }
            val customColumn = identityTable.columns.first { it.name == "id_custom" }
            val cycleColumn = identityTable.columns.first { it.name == "id_cycle" }
            val noCycleColumn = identityTable.columns.first { it.name == "id_no_cycle" }

            defaultColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            alwaysColumn.identityGeneration shouldBe Column.IdentityGeneration.ALWAYS
            customColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            cycleColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            noCycleColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT

            // Check auto-increment properties for SERIAL and IDENTITY columns

            // For SERIAL columns, check that they have the correct type and are auto-increment
            smallserialColumn.autoIncrement shouldBe true
            serialColumn.autoIncrement shouldBe true
            bigserialColumn.autoIncrement shouldBe true

            // For IDENTITY columns, check that they have the correct identity generation
            defaultColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            alwaysColumn.identityGeneration shouldBe Column.IdentityGeneration.ALWAYS
            customColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            cycleColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT
            noCycleColumn.identityGeneration shouldBe Column.IdentityGeneration.BY_DEFAULT

            resultDdl shouldBe originalDdl
        }
    }
})
