package momosetkn.maigreko.versioning

import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import momosetkn.JdbcDatabaseContainerDataSource
import momosetkn.PostgresqlDatabase
import momosetkn.maigreko.change.ChangeSet
import momosetkn.maigreko.change.Column
import momosetkn.maigreko.change.ColumnConstraint
import momosetkn.maigreko.change.CreateTable
import momosetkn.maigreko.sql.PostgresqlMigrateEngine
import momosetkn.maigreko.versioning.infras.ChangeSetHistoryRepository

class VersioningSpec : FunSpec({
    lateinit var versioning: Versioning
    lateinit var dataSource: javax.sql.DataSource
    lateinit var historyRepository: ChangeSetHistoryRepository

    val postgresqlMigrateEngine = PostgresqlMigrateEngine()

    beforeSpec {
        PostgresqlDatabase.start()
        val container = PostgresqlDatabase.startedContainer
        dataSource = JdbcDatabaseContainerDataSource(container)
        versioning = Versioning(dataSource, postgresqlMigrateEngine)
        historyRepository = ChangeSetHistoryRepository(dataSource)
    }

    beforeEach {
        PostgresqlDatabase.clear()
    }

    val sqlCommentRegex = Regex("^--.*\n", RegexOption.MULTILINE)
    fun String.deleteSqlComments(): String {
        return this.replace(sqlCommentRegex, "")
    }

    context("check ddl") {
        context("double forward") {
            test("can migrate") {
                val createTable = CreateTable(
                    tableName = "migrations",
                    columns = listOf(
                        Column(
                            name = "version",
                            type = "character varying(255)",
                            columnConstraint = ColumnConstraint(primaryKey = true, nullable = false)
                        )
                    )
                )

                val changeSet = ChangeSet(
                    migrationClass = "migrationClass",
                    changeSetId = 1,
                    changes = listOf(createTable),
                )

                versioning.forward(changeSet)
                versioning.forward(changeSet)

                PostgresqlDatabase.generateDdl().deleteSqlComments() shouldBe """
                --
                -- PostgreSQL database dump
                --


                SET statement_timeout = 0;
                SET lock_timeout = 0;
                SET idle_in_transaction_session_timeout = 0;
                SET transaction_timeout = 0;
                SET client_encoding = 'UTF8';
                SET standard_conforming_strings = on;
                SELECT pg_catalog.set_config('search_path', '', false);
                SET check_function_bodies = false;
                SET xmloption = content;
                SET client_min_messages = warning;
                SET row_security = off;

                --
                -- Name: public; Type: SCHEMA; Schema: -; Owner: test
                --

                -- *not* creating schema, since initdb creates it


                ALTER SCHEMA public OWNER TO test;

                --
                -- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: test
                --

                COMMENT ON SCHEMA public IS '';


                SET default_tablespace = '';

                SET default_table_access_method = heap;

                --
                -- Name: change_set_history; Type: TABLE; Schema: public; Owner: test
                --

                CREATE TABLE public.change_set_history (
                    id bigint NOT NULL,
                    migration_class character varying(255) NOT NULL,
                    change_set_id integer NOT NULL,
                    tag character varying(255),
                    applied_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
                );


                ALTER TABLE public.change_set_history OWNER TO test;

                --
                -- Name: change_set_history_id_seq; Type: SEQUENCE; Schema: public; Owner: test
                --

                ALTER TABLE public.change_set_history ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
                    SEQUENCE NAME public.change_set_history_id_seq
                    START WITH 1
                    INCREMENT BY 1
                    NO MINVALUE
                    NO MAXVALUE
                    CACHE 1
                );


                --
                -- Name: migrations; Type: TABLE; Schema: public; Owner: test
                --

                CREATE TABLE public.migrations (
                    version character varying(255) NOT NULL
                );


                ALTER TABLE public.migrations OWNER TO test;

                --
                -- Name: change_set_history change_set_history_pkey; Type: CONSTRAINT; Schema: public; Owner: test
                --

                ALTER TABLE ONLY public.change_set_history
                    ADD CONSTRAINT change_set_history_pkey PRIMARY KEY (id);


                --
                -- Name: migrations migrations_pkey; Type: CONSTRAINT; Schema: public; Owner: test
                --

                ALTER TABLE ONLY public.migrations
                    ADD CONSTRAINT migrations_pkey PRIMARY KEY (version);


                --
                -- Name: SCHEMA public; Type: ACL; Schema: -; Owner: test
                --

                REVOKE USAGE ON SCHEMA public FROM PUBLIC;


                --
                -- PostgreSQL database dump complete
                --


                """.trimIndent().deleteSqlComments()
            }
        }

        context("rollback") {
            test("can migrate") {
                val createTable = CreateTable(
                    tableName = "migrations",
                    columns = listOf(
                        Column(
                            name = "version",
                            type = "character varying(255)",
                            columnConstraint = ColumnConstraint(primaryKey = true, nullable = false)
                        )
                    )
                )

                val changeSet = ChangeSet(
                    migrationClass = "migrationClass",
                    changeSetId = 1,
                    changes = listOf(createTable),
                )

                versioning.forward(changeSet)
                versioning.rollback(changeSet)

                PostgresqlDatabase.generateDdl().deleteSqlComments() shouldBe """
                --
                -- PostgreSQL database dump
                --


                SET statement_timeout = 0;
                SET lock_timeout = 0;
                SET idle_in_transaction_session_timeout = 0;
                SET transaction_timeout = 0;
                SET client_encoding = 'UTF8';
                SET standard_conforming_strings = on;
                SELECT pg_catalog.set_config('search_path', '', false);
                SET check_function_bodies = false;
                SET xmloption = content;
                SET client_min_messages = warning;
                SET row_security = off;

                --
                -- Name: public; Type: SCHEMA; Schema: -; Owner: test
                --

                -- *not* creating schema, since initdb creates it


                ALTER SCHEMA public OWNER TO test;

                --
                -- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: test
                --

                COMMENT ON SCHEMA public IS '';


                SET default_tablespace = '';

                SET default_table_access_method = heap;

                --
                -- Name: change_set_history; Type: TABLE; Schema: public; Owner: test
                --

                CREATE TABLE public.change_set_history (
                    id bigint NOT NULL,
                    migration_class character varying(255) NOT NULL,
                    change_set_id integer NOT NULL,
                    tag character varying(255),
                    applied_at timestamp without time zone DEFAULT CURRENT_TIMESTAMP NOT NULL
                );


                ALTER TABLE public.change_set_history OWNER TO test;

                --
                -- Name: change_set_history_id_seq; Type: SEQUENCE; Schema: public; Owner: test
                --

                ALTER TABLE public.change_set_history ALTER COLUMN id ADD GENERATED BY DEFAULT AS IDENTITY (
                    SEQUENCE NAME public.change_set_history_id_seq
                    START WITH 1
                    INCREMENT BY 1
                    NO MINVALUE
                    NO MAXVALUE
                    CACHE 1
                );


                --
                -- Name: change_set_history change_set_history_pkey; Type: CONSTRAINT; Schema: public; Owner: test
                --

                ALTER TABLE ONLY public.change_set_history
                    ADD CONSTRAINT change_set_history_pkey PRIMARY KEY (id);


                --
                -- Name: SCHEMA public; Type: ACL; Schema: -; Owner: test
                --

                REVOKE USAGE ON SCHEMA public FROM PUBLIC;


                --
                -- PostgreSQL database dump complete
                --


                """.trimIndent().deleteSqlComments()
            }
        }
    }

    context("Migration pattern test") {

        // Helpers to build simple, independent change sets: A, B, C, D
        fun createTableChangeSet(id: Int, tableName: String): ChangeSet = ChangeSet(
            migrationClass = "migrationClass",
            changeSetId = id,
            changes = listOf(
                CreateTable(
                    tableName = tableName,
                    columns = listOf(
                        Column(
                            name = "id",
                            type = "bigint",
                            columnConstraint = ColumnConstraint(primaryKey = true, nullable = false)
                        )
                    )
                )
            )
        )

        val changeSetA = createTableChangeSet(1, "t_a")
        val changeSetB = createTableChangeSet(2, "t_b")
        val changeSetC = createTableChangeSet(3, "t_c")
        val changeSetD = createTableChangeSet(4, "t_d")

        fun historyIds(): Set<Int> = historyRepository.fetchAll().map { it.changeSetId }.toSet()

        beforeEach {
            PostgresqlDatabase.clear()
        }

        context("Forward (All)") {
            test("Apply A, B, C in order") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))

                historyIds() shouldBe setOf(
                    changeSetA.changeSetId,
                    changeSetB.changeSetId,
                    changeSetC.changeSetId,
                )
            }
        }

        context("Rollback (All)") {
            test("Rollback all applied A, B, C") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                versioning.rollback(listOf(changeSetA, changeSetB, changeSetC))

                historyIds() shouldBe emptySet()
            }
        }

        context("Forward → Rollback (All)") {
            test("A, B, C → rollback all") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                versioning.rollback(listOf(changeSetA, changeSetB, changeSetC))

                historyIds() shouldBe emptySet()
            }
        }

        context("Rollback → Forward (All)") {
            test("After rollback → apply A, B, C again") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                versioning.rollback(listOf(changeSetA, changeSetB, changeSetC))
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                // idempotency check: calling forward again should keep same state
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))

                historyIds() shouldBe setOf(
                    changeSetA.changeSetId,
                    changeSetB.changeSetId,
                    changeSetC.changeSetId,
                )
            }
        }

        context("Forward (Partial)") {
            test("A only") {
                versioning.forward(changeSetA)
                historyIds() shouldBe setOf(changeSetA.changeSetId)
            }

            test("A, B only") {
                versioning.forward(listOf(changeSetA, changeSetB))
                historyIds() shouldBe setOf(changeSetA.changeSetId, changeSetB.changeSetId)
            }

            test("B, C only") {
                versioning.forward(listOf(changeSetB, changeSetC))
                historyIds() shouldBe setOf(changeSetB.changeSetId, changeSetC.changeSetId)
            }
        }

        context("Rollback (Partial)") {
            test("Applied A, B, C → rollback C only") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                versioning.rollback(changeSetC)

                historyIds() shouldBe setOf(changeSetA.changeSetId, changeSetB.changeSetId)
            }
        }

        context("Forward → Rollback (Partial)") {
            test("Applied A, B → rollback B → re-apply B") {
                versioning.forward(listOf(changeSetA, changeSetB))
                versioning.rollback(changeSetB)

                historyIds() shouldBe setOf(changeSetA.changeSetId)

                versioning.forward(changeSetB)
                historyIds() shouldBe setOf(changeSetA.changeSetId, changeSetB.changeSetId)
            }
        }

        context("Rollback → Forward (Partial)") {
            test("Applied A, B, C → rollback B → forward C → re-apply B") {
                versioning.forward(listOf(changeSetA, changeSetB, changeSetC))
                versioning.rollback(changeSetB)

                // Apply C forward again (should be no-op and remain consistent)
                versioning.forward(changeSetC)
                historyIds() shouldBe setOf(changeSetA.changeSetId, changeSetC.changeSetId)

                // Re-apply B
                versioning.forward(changeSetB)
                historyIds() shouldBe setOf(
                    changeSetA.changeSetId,
                    changeSetB.changeSetId,
                    changeSetC.changeSetId,
                )
            }
        }

        context("Forward with gaps") {
            test("Apply A, C, D → apply B later") {
                versioning.forward(listOf(changeSetA, changeSetC, changeSetD))
                historyIds() shouldBe setOf(
                    changeSetA.changeSetId,
                    changeSetC.changeSetId,
                    changeSetD.changeSetId,
                )

                versioning.forward(changeSetB)
                historyIds() shouldBe setOf(
                    changeSetA.changeSetId,
                    changeSetB.changeSetId,
                    changeSetC.changeSetId,
                    changeSetD.changeSetId,
                )
            }
        }
    }
})
